/*
 * DateTime.c
 *
 *  Created on: Jun 30, 2022
 *      Author: student
 */
#include "DateTime.h"

#define MAX_BUFFER_LENGTH 100

uint8_t cmdbuffer[MAX_BUFFER_LENGTH];
int cmdcount = 0;
int cmdprint = 0;


void clockInit(CLOCK *clk,TIME *tm,I2C_HandleTypeDef *hi2c1){
	if(clk == NULL){
			return;
	}
	clk->time.year=tm->year;
	clk->time.month=tm->month;
	clk->time.date=tm->date;
	clk->time.hour = tm->hour;
	clk->time.minute = tm->minute;
	clk->time.second = tm->second;
	clk->hi2c1 = hi2c1;
}

void I2CMemWrite(CLOCK *clk){
	//uint8_t arrData[] = {0,0,0,1,1,1,1};
	uint8_t arrData[7];
	arrData[0] = dec2Bin(clk->time.second);
	arrData[1] = dec2Bin(clk->time.minute);
	arrData[2] = dec2Bin(clk->time.hour);
	arrData[3] = dec2Bin(clk->time.date);
	arrData[4] = dec2Bin(clk->time.month);
	arrData[5] = dec2Bin(clk->time.year);
	arrData[6] = 1;
	HAL_I2C_Mem_Write(clk->hi2c1, 0XD0, 0, 1, arrData, 7, 0XFF);
}
uint8_t dec2Bin(uint8_t dec){
	uint8_t right = dec % 10;
	uint8_t left = dec / 10;
	return (left <<4)|right;

}

void printDateTime(CLOCK *clk){
	uint8_t readBuff[7];
	TIME tm;
	HAL_I2C_Mem_Read(clk->hi2c1, 0XD0, 0, 1, readBuff, 7, 0xff);
	tm.second = GetRight4BitNum(readBuff[0]); //(readBuff[0] & 15);
	tm.second10 = GetLeft4BitNum(readBuff[0]);//(readBuff[0] >> 4);
	tm.minute = GetRight4BitNum(readBuff[1]);//(readBuff[1] & 15);
	tm.minute10 = GetLeft4BitNum(readBuff[1]);//(readBuff[1] >>4);
	tm.hour = GetRight4BitNum(readBuff[2]);//(readBuff[2] & 15);
	tm.hour10 = GetLeft4BitNum(readBuff[2]);//(readBuff[2] >> 4);
	//clk->days = readBuff[3];
	tm.date = GetRight4BitNum(readBuff[4]);//(readBuff[4] & 15);
	tm.date10 = GetLeft4BitNum(readBuff[4]);//(readBuff[4] >> 4);
	tm.month = GetRight4BitNum(readBuff[5]);//(readBuff[5] & 15);
	tm.month10 = GetLeft4BitNum(readBuff[5]);//(readBuff[5] >> 4);
	tm.year = GetRight4BitNum(readBuff[6]);//(readBuff[5] & 15);
	tm.year10 = GetLeft4BitNum(readBuff[6]);//(readBuff[5] >> 4);

	  printf("year month date day hour min sec \n\r");
	  printf("20%d%d:%d%d:%d%d:%d:%d%d:%d%d:%d%d \n\r" ,
			  tm.year10, tm.year, tm.month10, tm.month,
			  tm.date10, tm.date, /*clk->days*/0, tm.hour10, tm.hour,
			  tm.minute10,
			  tm.minute,
			  tm.second10,
			  tm.second);
}

//left and right >0 and <15
uint8_t setLeftRight8bitNum(uint8_t *lAndr,uint8_t  left, uint8_t  right) {
    uint8_t ret = 1;
    if (left > 15 || right > 15) {
        ret = 0;
    }
    else {
        *lAndr = left<<4;//move 4 bit left
        *lAndr = *lAndr | right;
    }
    return ret;
}

uint8_t GetRight4BitNum(uint8_t num)
{
    return num & 0XF;
}

uint8_t GetLeft4BitNum(uint8_t num) {
    return num >> 4;
}

int commTask(UART_HandleTypeDef *huart2)
{
	uint8_t ch;

	HAL_StatusTypeDef Status = HAL_UART_Receive(huart2, &ch, 1, 10);
	if (Status != HAL_OK)
	{
		if((huart2->Instance->ISR & USART_ISR_ORE) != 0)
		{
			__HAL_UART_CLEAR_OREFLAG(huart2);
		}

		// here we have a time to print the command
		while (cmdprint < cmdcount)
		{
			HAL_UART_Transmit(huart2, &cmdbuffer[cmdprint++], 1, 0xFFFF);
		}

		return 0;
	}

	if (ch != '\r' && ch != '\n')
	{
		//HAL_UART_Transmit(&huart2, &ch, 1, 0xFFFF);

		if (cmdcount >= MAX_BUFFER_LENGTH)
		{
			cmdcount = 0;
			cmdprint = 0;
		}

		cmdbuffer[cmdcount++] = ch;
		return 0;
	}

	// here we have a time to print the command
	while (cmdprint < cmdcount)
	{
		HAL_UART_Transmit(huart2, &cmdbuffer[cmdprint++], 1, 0xFFFF);
	}

	HAL_UART_Transmit(huart2, (uint8_t*)"\r\n", 2, 0xFFFF);

	cmdbuffer[cmdcount] = 0;
	cmdcount = 0;
	cmdprint = 0;
	return 1;
}

uint8_t handleCommand(TIME *tm)
{
  char cmd[20];
 // TIME tm;
  uint8_t ret = 0;

  int params = sscanf((const char*)cmdbuffer, "%s %d:%d:%d:%d:%d:%d", cmd,
		  &tm->year,&tm->month,&tm->date,&tm->hour,&tm->minute,&tm->second);

  if (params == 0)
  {
	  return 1;
  }

  if (strcmp(cmd, "set") == 0)
  {
	  //ledStart(maxCount);
	  ret =1;

  }else
  {
	  printf("Invalid command\r\n");
	  ret = 0;
  }
  return ret;
}





