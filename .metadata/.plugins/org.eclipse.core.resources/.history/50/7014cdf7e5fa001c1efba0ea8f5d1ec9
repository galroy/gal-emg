/*
 * DateTime.c
 *
 *  Created on: Jun 30, 2022
 *      Author: student
 */
#include "DateTime.h"

#define MAX_BUFFER_LENGTH 100

uint8_t cmdbuffer[MAX_BUFFER_LENGTH];
int cmdcount = 0;
int cmdprint = 0;


void clockInit(CLOCK *clk,TIME *tm,I2C_HandleTypeDef *hi2c1){
	if(clk == NULL){
			return;
	}
	clk->time.year=tm->year;
	clk->time.month=tm->month;
	clk->time.date=tm->date;
	clk->time.hour = tm->hour;
	clk->time.minute = tm->minute;
	clk->time.second = tm->second;
	clk->hi2c1 = hi2c1;
}

void I2CMemWrite(CLOCK *clk){
	uint8_t arrData[] = {0,0,0,1,1,1,1};
	HAL_I2C_Mem_Write(clk->hi2c1, 0XD0, 0, 1, arrData, 7, 0XFF);
}

void printDateTime(CLOCK *clk){
	uint8_t readBuff[7];
	TIME tm;
	HAL_I2C_Mem_Read(clk->hi2c1, 0XD0, 0, 1, readBuff, 7, 0xff);
	tm.second = GetRight4BitNum(readBuff[0]); //(readBuff[0] & 15);
	tm.second10 = GetLeft4BitNum(readBuff[0]);//(readBuff[0] >> 4);
	tm.minute = GetRight4BitNum(readBuff[1]);//(readBuff[1] & 15);
	tm.minute10 = GetLeft4BitNum(readBuff[1]);//(readBuff[1] >>4);
	tm.hour = GetRight4BitNum(readBuff[2]);//(readBuff[2] & 15);
	tm.hour10 = GetLeft4BitNum(readBuff[2]);//(readBuff[2] >> 4);
	//clk->days = readBuff[3];
	tm.date = GetRight4BitNum(readBuff[4]);//(readBuff[4] & 15);
	tm.date10 = GetLeft4BitNum(readBuff[4]);//(readBuff[4] >> 4);
	tm.month = GetRight4BitNum(readBuff[5]);//(readBuff[5] & 15);
	tm.month10 = GetLeft4BitNum(readBuff[5]);//(readBuff[5] >> 4);
	tm.year = GetRight4BitNum(readBuff[6]);//(readBuff[5] & 15);
	tm.year10 = GetLeft4BitNum(readBuff[6]);//(readBuff[5] >> 4);

	  printf("year month date day hour min sec \n\r");
	  printf("20%d%d:%d%d:%d%d:%d:%d%d:%d%d:%d%d \n\r" ,
			  tm.year10, tm.year, tm.month10, tm.month,
			  tm.date10, tm.date, /*clk->days*/0, tm.hour10, tm.hour,
			  tm.minute10,
			  tm.minute,
			  tm.second10,
			  tm.second);
}

//left and right >0 and <15
uint8_t setLeftRight8bitNum(uint8_t *lAndr,uint8_t  left, uint8_t  right) {
    uint8_t ret = 1;
    if (left > 15 || right > 15) {
        ret = 0;
    }
    else {
        *lAndr = left<<4;//move 4 bit left
        *lAndr = *lAndr | right;
    }
    return ret;
}

uint8_t GetRight4BitNum(uint8_t num)
{
    return num & 0XF;
}

uint8_t GetLeft4BitNum(uint8_t num) {
    return num >> 4;
}

int commTask(UART_HandleTypeDef *huart2)
{
	uint8_t ch;

	HAL_StatusTypeDef Status = HAL_UART_Receive(huart2, &ch, 1, 10);
	if (Status != HAL_OK)
	{
		if((huart2->Instance->ISR & USART_ISR_ORE) != 0)
		{
			__HAL_UART_CLEAR_OREFLAG(huart2);
		}

		// here we have a time to print the command
		while (cmdprint < cmdcount)
		{
			HAL_UART_Transmit(huart2, &cmdbuffer[cmdprint++], 1, 0xFFFF);
		}

		return 0;
	}

	if (ch != '\r' && ch != '\n')
	{
		//HAL_UART_Transmit(&huart2, &ch, 1, 0xFFFF);

		if (cmdcount >= MAX_BUFFER_LENGTH)
		{
			cmdcount = 0;
			cmdprint = 0;
		}

		cmdbuffer[cmdcount++] = ch;
		return 0;
	}

	// here we have a time to print the command
	while (cmdprint < cmdcount)
	{
		HAL_UART_Transmit(&huart2, &cmdbuffer[cmdprint++], 1, 0xFFFF);
	}

	HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 0xFFFF);

	cmdbuffer[cmdcount] = 0;
	cmdcount = 0;
	cmdprint = 0;
	return 1;
}

void handleCommand()
{
  char cmd[20];
  int maxCount;

  int params = sscanf((const char*)cmdbuffer, "%s %d", cmd, &maxCount);

  if (params == 0)
  {
	  return;
  }

  if (strcmp(cmd, "start") == 0)
  {
	  ledStart(maxCount);
  }
  else if (strcmp(cmd, "stop") == 0)
  {
	  ledStop();
  }
  else
  {
	  printf("Invalid command\r\n");
  }
}





